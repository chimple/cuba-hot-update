{"version":3,"file":"static/js/81.468b78b2.chunk.js","mappings":"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","sources":["../node_modules/@capacitor/filesystem/src/web.ts"],"sourcesContent":["import { WebPlugin, buildRequestInit } from '@capacitor/core';\n\nimport type {\n  AppendFileOptions,\n  CopyOptions,\n  CopyResult,\n  DeleteFileOptions,\n  FilesystemPlugin,\n  GetUriOptions,\n  GetUriResult,\n  MkdirOptions,\n  PermissionStatus,\n  ReadFileOptions,\n  ReadFileResult,\n  ReaddirOptions,\n  ReaddirResult,\n  RenameOptions,\n  RmdirOptions,\n  StatOptions,\n  StatResult,\n  WriteFileOptions,\n  WriteFileResult,\n  Directory,\n  DownloadFileOptions,\n  DownloadFileResult,\n  ProgressStatus,\n} from './definitions';\nimport { Encoding } from './definitions';\n\nfunction resolve(path: string): string {\n  const posix = path.split('/').filter(item => item !== '.');\n  const newPosix: string[] = [];\n\n  posix.forEach(item => {\n    if (\n      item === '..' &&\n      newPosix.length > 0 &&\n      newPosix[newPosix.length - 1] !== '..'\n    ) {\n      newPosix.pop();\n    } else {\n      newPosix.push(item);\n    }\n  });\n\n  return newPosix.join('/');\n}\nfunction isPathParent(parent: string, children: string): boolean {\n  parent = resolve(parent);\n  children = resolve(children);\n  const pathsA = parent.split('/');\n  const pathsB = children.split('/');\n\n  return (\n    parent !== children &&\n    pathsA.every((value, index) => value === pathsB[index])\n  );\n}\n\nexport class FilesystemWeb extends WebPlugin implements FilesystemPlugin {\n  DB_VERSION = 1;\n  DB_NAME = 'Disc';\n\n  private _writeCmds: string[] = ['add', 'put', 'delete'];\n  private _db?: IDBDatabase;\n  static _debug = true;\n  async initDb(): Promise<IDBDatabase> {\n    if (this._db !== undefined) {\n      return this._db;\n    }\n    if (!('indexedDB' in window)) {\n      throw this.unavailable(\"This browser doesn't support IndexedDB\");\n    }\n\n    return new Promise<IDBDatabase>((resolve, reject) => {\n      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n      request.onupgradeneeded = FilesystemWeb.doUpgrade;\n      request.onsuccess = () => {\n        this._db = request.result;\n        resolve(request.result);\n      };\n      request.onerror = () => reject(request.error);\n      request.onblocked = () => {\n        console.warn('db blocked');\n      };\n    });\n  }\n\n  static doUpgrade(event: IDBVersionChangeEvent): void {\n    const eventTarget = event.target as IDBOpenDBRequest;\n    const db = eventTarget.result;\n    switch (event.oldVersion) {\n      case 0:\n      case 1:\n      default: {\n        if (db.objectStoreNames.contains('FileStorage')) {\n          db.deleteObjectStore('FileStorage');\n        }\n        const store = db.createObjectStore('FileStorage', { keyPath: 'path' });\n        store.createIndex('by_folder', 'folder');\n      }\n    }\n  }\n\n  async dbRequest(cmd: string, args: any[]): Promise<any> {\n    const readFlag =\n      this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then((conn: IDBDatabase) => {\n      return new Promise<IDBObjectStore>((resolve, reject) => {\n        const tx: IDBTransaction = conn.transaction(['FileStorage'], readFlag);\n        const store: any = tx.objectStore('FileStorage');\n        const req = store[cmd](...args);\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  async dbIndexRequest(\n    indexName: string,\n    cmd: string,\n    args: [any],\n  ): Promise<any> {\n    const readFlag =\n      this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then((conn: IDBDatabase) => {\n      return new Promise<IDBObjectStore>((resolve, reject) => {\n        const tx: IDBTransaction = conn.transaction(['FileStorage'], readFlag);\n        const store: IDBObjectStore = tx.objectStore('FileStorage');\n        const index: any = store.index(indexName);\n        const req = index[cmd](...args) as any;\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  private getPath(\n    directory: Directory | undefined,\n    uriPath: string | undefined,\n  ): string {\n    const cleanedUriPath =\n      uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n    let fsPath = '';\n    if (directory !== undefined) fsPath += '/' + directory;\n    if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n    return fsPath;\n  }\n\n  async clear(): Promise<void> {\n    const conn: IDBDatabase = await this.initDb();\n    const tx: IDBTransaction = conn.transaction(['FileStorage'], 'readwrite');\n    const store: IDBObjectStore = tx.objectStore('FileStorage');\n    store.clear();\n  }\n\n  /**\n   * Read a file from disk\n   * @param options options for the file read\n   * @return a promise that resolves with the read file data result\n   */\n  async readFile(options: ReadFileOptions): Promise<ReadFileResult> {\n    const path: string = this.getPath(options.directory, options.path);\n    // const encoding = options.encoding;\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) throw Error('File does not exist.');\n    return { data: entry.content ? entry.content : '' };\n  }\n\n  /**\n   * Write a file to disk in the specified location on device\n   * @param options options for the file write\n   * @return a promise that resolves with the file write result\n   */\n  async writeFile(options: WriteFileOptions): Promise<WriteFileResult> {\n    const path: string = this.getPath(options.directory, options.path);\n    let data = options.data;\n    const encoding = options.encoding;\n    const doRecursive = options.recursive;\n\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (occupiedEntry && occupiedEntry.type === 'directory')\n      throw Error('The supplied path is a directory.');\n\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: doRecursive,\n        });\n      }\n    }\n\n    if (!encoding) {\n      data = data.indexOf(',') >= 0 ? data.split(',')[1] : data;\n      if (!this.isBase64String(data))\n        throw Error('The supplied data is not valid base64 content.');\n    }\n\n    const now = Date.now();\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: now,\n      mtime: now,\n      content: data,\n    };\n    await this.dbRequest('put', [pathObj]);\n    return {\n      uri: pathObj.path,\n    };\n  }\n\n  /**\n   * Append to a file on disk in the specified location on device\n   * @param options options for the file append\n   * @return a promise that resolves with the file write result\n   */\n  async appendFile(options: AppendFileOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n    let data = options.data;\n    const encoding = options.encoding;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const now = Date.now();\n    let ctime = now;\n\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (occupiedEntry && occupiedEntry.type === 'directory')\n      throw Error('The supplied path is a directory.');\n\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: true,\n        });\n      }\n    }\n\n    if (!encoding && !this.isBase64String(data))\n      throw Error('The supplied data is not valid base64 content.');\n\n    if (occupiedEntry !== undefined) {\n      if (occupiedEntry.content !== undefined && !encoding) {\n        data = btoa(atob(occupiedEntry.content) + atob(data));\n      } else {\n        data = occupiedEntry.content + data;\n      }\n      ctime = occupiedEntry.ctime;\n    }\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: ctime,\n      mtime: now,\n      content: data,\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n\n  /**\n   * Delete a file from disk\n   * @param options options for the file delete\n   * @return a promise that resolves with the deleted file data result\n   */\n  async deleteFile(options: DeleteFileOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) throw Error('File does not exist.');\n    const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [\n      IDBKeyRange.only(path),\n    ]);\n    if (entries.length !== 0) throw Error('Folder is not empty.');\n\n    await this.dbRequest('delete', [path]);\n  }\n\n  /**\n   * Create a directory.\n   * @param options options for the mkdir\n   * @return a promise that resolves with the mkdir result\n   */\n  async mkdir(options: MkdirOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n    const doRecursive = options.recursive;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const depth = (path.match(/\\//g) || []).length;\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (depth === 1) throw Error('Cannot create Root directory');\n    if (occupiedEntry !== undefined)\n      throw Error('Current directory does already exist.');\n    if (!doRecursive && depth !== 2 && parentEntry === undefined)\n      throw Error('Parent directory must exist');\n\n    if (doRecursive && depth !== 2 && parentEntry === undefined) {\n      const parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n      await this.mkdir({\n        path: parentArgPath,\n        directory: options.directory,\n        recursive: doRecursive,\n      });\n    }\n    const now = Date.now();\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'directory',\n      size: 0,\n      ctime: now,\n      mtime: now,\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n\n  /**\n   * Remove a directory\n   * @param options the options for the directory remove\n   */\n  async rmdir(options: RmdirOptions): Promise<void> {\n    const { path, directory, recursive } = options;\n    const fullPath: string = this.getPath(directory, path);\n\n    const entry = (await this.dbRequest('get', [fullPath])) as EntryObj;\n\n    if (entry === undefined) throw Error('Folder does not exist.');\n\n    if (entry.type !== 'directory')\n      throw Error('Requested path is not a directory');\n\n    const readDirResult = await this.readdir({ path, directory });\n\n    if (readDirResult.files.length !== 0 && !recursive)\n      throw Error('Folder is not empty');\n\n    for (const entry of readDirResult.files) {\n      const entryPath = `${path}/${entry.name}`;\n      const entryObj = await this.stat({ path: entryPath, directory });\n      if (entryObj.type === 'file') {\n        await this.deleteFile({ path: entryPath, directory });\n      } else {\n        await this.rmdir({ path: entryPath, directory, recursive });\n      }\n    }\n\n    await this.dbRequest('delete', [fullPath]);\n  }\n\n  /**\n   * Return a list of files from the directory (not recursive)\n   * @param options the options for the readdir operation\n   * @return a promise that resolves with the readdir directory listing result\n   */\n  async readdir(options: ReaddirOptions): Promise<ReaddirResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (options.path !== '' && entry === undefined)\n      throw Error('Folder does not exist.');\n\n    const entries: string[] = await this.dbIndexRequest(\n      'by_folder',\n      'getAllKeys',\n      [IDBKeyRange.only(path)],\n    );\n    const files = await Promise.all(\n      entries.map(async e => {\n        let subEntry = (await this.dbRequest('get', [e])) as EntryObj;\n        if (subEntry === undefined) {\n          subEntry = (await this.dbRequest('get', [e + '/'])) as EntryObj;\n        }\n        return {\n          name: e.substring(path.length + 1),\n          type: subEntry.type,\n          size: subEntry.size,\n          ctime: subEntry.ctime,\n          mtime: subEntry.mtime,\n          uri: subEntry.path,\n        };\n      }),\n    );\n    return { files: files };\n  }\n\n  /**\n   * Return full File URI for a path and directory\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async getUri(options: GetUriOptions): Promise<GetUriResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    let entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) {\n      entry = (await this.dbRequest('get', [path + '/'])) as EntryObj;\n    }\n    return {\n      uri: entry?.path || path,\n    };\n  }\n\n  /**\n   * Return data about a file\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async stat(options: StatOptions): Promise<StatResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    let entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) {\n      entry = (await this.dbRequest('get', [path + '/'])) as EntryObj;\n    }\n    if (entry === undefined) throw Error('Entry does not exist.');\n\n    return {\n      type: entry.type,\n      size: entry.size,\n      ctime: entry.ctime,\n      mtime: entry.mtime,\n      uri: entry.path,\n    };\n  }\n\n  /**\n   * Rename a file or directory\n   * @param options the options for the rename operation\n   * @return a promise that resolves with the rename result\n   */\n  async rename(options: RenameOptions): Promise<void> {\n    await this._copy(options, true);\n    return;\n  }\n\n  /**\n   * Copy a file or directory\n   * @param options the options for the copy operation\n   * @return a promise that resolves with the copy result\n   */\n  async copy(options: CopyOptions): Promise<CopyResult> {\n    return this._copy(options, false);\n  }\n\n  async requestPermissions(): Promise<PermissionStatus> {\n    return { publicStorage: 'granted' };\n  }\n\n  async checkPermissions(): Promise<PermissionStatus> {\n    return { publicStorage: 'granted' };\n  }\n\n  /**\n   * Function that can perform a copy or a rename\n   * @param options the options for the rename operation\n   * @param doRename whether to perform a rename or copy operation\n   * @return a promise that resolves with the result\n   */\n  private async _copy(\n    options: CopyOptions,\n    doRename = false,\n  ): Promise<CopyResult> {\n    let { toDirectory } = options;\n    const { to, from, directory: fromDirectory } = options;\n\n    if (!to || !from) {\n      throw Error('Both to and from must be provided');\n    }\n\n    // If no \"to\" directory is provided, use the \"from\" directory\n    if (!toDirectory) {\n      toDirectory = fromDirectory;\n    }\n\n    const fromPath = this.getPath(fromDirectory, from);\n    const toPath = this.getPath(toDirectory, to);\n\n    // Test that the \"to\" and \"from\" locations are different\n    if (fromPath === toPath) {\n      return {\n        uri: toPath,\n      };\n    }\n\n    if (isPathParent(fromPath, toPath)) {\n      throw Error('To path cannot contain the from path');\n    }\n\n    // Check the state of the \"to\" location\n    let toObj;\n    try {\n      toObj = await this.stat({\n        path: to,\n        directory: toDirectory,\n      });\n    } catch (e) {\n      // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n      const toPathComponents = to.split('/');\n      toPathComponents.pop();\n      const toPath = toPathComponents.join('/');\n\n      // Check the containing directory of the \"to\" location exists\n      if (toPathComponents.length > 0) {\n        const toParentDirectory = await this.stat({\n          path: toPath,\n          directory: toDirectory,\n        });\n\n        if (toParentDirectory.type !== 'directory') {\n          throw new Error('Parent directory of the to path is a file');\n        }\n      }\n    }\n\n    // Cannot overwrite a directory\n    if (toObj && toObj.type === 'directory') {\n      throw new Error('Cannot overwrite a directory with a file');\n    }\n\n    // Ensure the \"from\" object exists\n    const fromObj = await this.stat({\n      path: from,\n      directory: fromDirectory,\n    });\n\n    // Set the mtime/ctime of the supplied path\n    const updateTime = async (path: string, ctime: number, mtime: number) => {\n      const fullPath: string = this.getPath(toDirectory, path);\n      const entry = (await this.dbRequest('get', [fullPath])) as EntryObj;\n      entry.ctime = ctime;\n      entry.mtime = mtime;\n      await this.dbRequest('put', [entry]);\n    };\n\n    const ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n\n    switch (fromObj.type) {\n      // The \"from\" object is a file\n      case 'file': {\n        // Read the file\n        const file = await this.readFile({\n          path: from,\n          directory: fromDirectory,\n        });\n\n        // Optionally remove the file\n        if (doRename) {\n          await this.deleteFile({\n            path: from,\n            directory: fromDirectory,\n          });\n        }\n\n        let encoding;\n        if (!this.isBase64String(file.data)) {\n          encoding = Encoding.UTF8;\n        }\n\n        // Write the file to the new location\n        const writeResult = await this.writeFile({\n          path: to,\n          directory: toDirectory,\n          data: file.data,\n          encoding: encoding,\n        });\n\n        // Copy the mtime/ctime of a renamed file\n        if (doRename) {\n          await updateTime(to, ctime, fromObj.mtime);\n        }\n\n        // Resolve promise\n        return writeResult;\n      }\n      case 'directory': {\n        if (toObj) {\n          throw Error('Cannot move a directory over an existing object');\n        }\n\n        try {\n          // Create the to directory\n          await this.mkdir({\n            path: to,\n            directory: toDirectory,\n            recursive: false,\n          });\n\n          // Copy the mtime/ctime of a renamed directory\n          if (doRename) {\n            await updateTime(to, ctime, fromObj.mtime);\n          }\n        } catch (e) {\n          // ignore\n        }\n\n        // Iterate over the contents of the from location\n        const contents = (\n          await this.readdir({\n            path: from,\n            directory: fromDirectory,\n          })\n        ).files;\n\n        for (const filename of contents) {\n          // Move item from the from directory to the to directory\n          await this._copy(\n            {\n              from: `${from}/${filename.name}`,\n              to: `${to}/${filename.name}`,\n              directory: fromDirectory,\n              toDirectory,\n            },\n            doRename,\n          );\n        }\n\n        // Optionally remove the original from directory\n        if (doRename) {\n          await this.rmdir({\n            path: from,\n            directory: fromDirectory,\n          });\n        }\n      }\n    }\n    return {\n      uri: toPath,\n    };\n  }\n\n  /**\n   * Function that performs a http request to a server and downloads the file to the specified destination\n   *\n   * @param options the options for the download operation\n   * @returns a promise that resolves with the download file result\n   */\n  public downloadFile = async (\n    options: DownloadFileOptions,\n  ): Promise<DownloadFileResult> => {\n    const requestInit = buildRequestInit(options, options.webFetchExtra);\n    const response = await fetch(options.url, requestInit);\n    let blob: Blob;\n\n    if (!options?.progress) blob = await response.blob();\n    else if (!response?.body) blob = new Blob();\n    else {\n      const reader = response.body.getReader();\n\n      let bytes = 0;\n      const chunks: (Uint8Array | undefined)[] = [];\n\n      const contentType: string | null = response.headers.get('content-type');\n      const contentLength: number = parseInt(\n        response.headers.get('content-length') || '0',\n        10,\n      );\n\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) break;\n\n        chunks.push(value);\n        bytes += value?.length || 0;\n\n        const status: ProgressStatus = {\n          url: options.url,\n          bytes,\n          contentLength,\n        };\n\n        this.notifyListeners('progress', status);\n      }\n\n      const allChunks = new Uint8Array(bytes);\n      let position = 0;\n      for (const chunk of chunks) {\n        if (typeof chunk === 'undefined') continue;\n\n        allChunks.set(chunk, position);\n        position += chunk.length;\n      }\n\n      blob = new Blob([allChunks.buffer], { type: contentType || undefined });\n    }\n\n    const blobUrl = URL.createObjectURL(blob);\n    const tempAnchor = document.createElement('a');\n    document.body.appendChild(tempAnchor);\n\n    tempAnchor.href = blobUrl;\n    tempAnchor.download = options.path; // This should be a filename, not a path\n    tempAnchor.click();\n\n    URL.revokeObjectURL(blobUrl);\n    document.body.removeChild(tempAnchor);\n\n    return { path: options.path, blob };\n  };\n\n  private isBase64String(str: string): boolean {\n    try {\n      return btoa(atob(str)) == str;\n    } catch (err) {\n      return false;\n    }\n  }\n}\n\ninterface EntryObj {\n  path: string;\n  folder: string;\n  type: 'directory' | 'file';\n  size: number;\n  ctime: number;\n  mtime: number;\n  uri?: string;\n  content?: string;\n}\n"],"names":["resolve","path","posix","split","filter","item","newPosix","forEach","length","pop","push","join","isPathParent","parent","children","pathsA","pathsB","every","value","index","FilesystemWeb","_WebPlugin","_inherits","_super","_createSuper","_this","_classCallCheck","DB_VERSION","DB_NAME","_writeCmds","downloadFile","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","options","requestInit","response","blob","reader","bytes","chunks","contentType","contentLength","_yield$reader$read","done","status","allChunks","position","_i","_chunks","chunk","blobUrl","tempAnchor","wrap","_context","prev","next","buildRequestInit","webFetchExtra","fetch","url","sent","progress","body","Blob","getReader","headers","get","parseInt","read","abrupt","notifyListeners","Uint8Array","set","buffer","type","undefined","URL","createObjectURL","document","createElement","appendChild","href","download","click","revokeObjectURL","removeChild","stop","_x","apply","arguments","_createClass","key","_initDb","_callee2","_this2","_context2","this","_db","window","unavailable","Promise","reject","request","indexedDB","open","onupgradeneeded","doUpgrade","onsuccess","result","onerror","error","onblocked","console","warn","_dbRequest","_callee3","cmd","args","readFlag","_context3","indexOf","initDb","then","conn","store","transaction","objectStore","req","_toConsumableArray","_x2","_x3","_dbIndexRequest","_callee4","indexName","_context4","_x4","_x5","_x6","directory","uriPath","cleanedUriPath","replace","fsPath","_clear","_callee5","tx","_context5","clear","_readFile","_callee6","entry","_context6","getPath","dbRequest","Error","data","content","_x7","_writeFile","_callee7","encoding","doRecursive","occupiedEntry","parentPath","subDirIndex","parentArgPath","now","pathObj","_context7","recursive","substr","lastIndexOf","mkdir","isBase64String","Date","folder","size","ctime","mtime","uri","_x8","_appendFile","_callee8","_context8","btoa","atob","_x9","_deleteFile","_callee9","_context9","dbIndexRequest","IDBKeyRange","only","_x10","_mkdir","_callee10","depth","parentEntry","_context10","match","_x11","_rmdir","_callee11","fullPath","readDirResult","_iterator","_step","_entry","entryPath","_context11","readdir","files","_createForOfIteratorHelper","s","n","concat","name","stat","deleteFile","rmdir","t0","e","f","finish","_x12","_readdir","_callee13","entries","_this3","_context13","all","map","_ref2","_callee12","subEntry","_context12","substring","_x14","_x13","_getUri","_callee14","_context14","_x15","_stat","_callee15","_context15","_x16","_rename","_callee16","_context16","_copy","_x17","_copy2","_callee17","_context17","_x18","_requestPermissions","_callee18","_context18","publicStorage","_checkPermissions","_callee19","_context19","_copy3","_callee21","doRename","toDirectory","to","from","fromDirectory","fromPath","toPath","toObj","toPathComponents","_toPath","fromObj","updateTime","file","writeResult","contents","_iterator2","_step2","filename","_this4","_args21","_context21","_ref3","_callee20","_context20","_x20","_x21","_x22","t1","readFile","Encoding","UTF8","writeFile","t2","t3","_x19","str","err","event","db","target","oldVersion","objectStoreNames","contains","deleteObjectStore","createObjectStore","keyPath","createIndex","WebPlugin","_debug"],"sourceRoot":""}